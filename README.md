# fhir.emf

## A full implemtation of the FHIR 4.0.1 specification built using EMF (eclipse modeling framework).  
&nbsp;

This project is intended to be used as a data model.  A likely use case might be as the model component of a webservice.  

Code is generated using the [XML schema](http://hl7.org/fhir/R4/xml.html#schema) taken from the FHIR specification.  This schema(s) can be found in the model directory.

    model/fhir-codegen-xsd  

Because the code is generated, it can be regenerated.  If and when HL7 changes the specification; a new, conformant code base can be had.  

An EMF generated code base offers some benefits over hand written.  

1. The code is fully compliant with the specification.
2. The API is consistent with no odd little anomalies.
3. A graph of EMF objects can be de/serialized to/from a variety of formats.  XMI, XML, and JSON are currently supported.  RDF (resource description framework) and AA (associative array) can be implemented by following the same pattern as say XML and can work consistently.  
4. EMF supports it's own reflection capability similar to Java's but more efficient and easier to use.  
&nbsp;

Because this is a full, complete implementation; it supports Structure Definiition and can therefore be used to define a FHIR [profile](http://hl7.org/fhir/R4/profiling.html#5.1.0).  However, [extensions](http://hl7.org/fhir/R4/profiling.html#api) are by their nature additions to the FHIR specification and will likely require additional code.  
&nbsp;


fhir.emf accomodates the differences between FHIR's XML and JSON de/serializations.  Without these accomodations, de/serialization to XML would be conformant but JSON would be non-conformant.

Source code is maintained in two locations:  

1. Code written to perform the accomodation (mentioned above).    

    src/main/java  

2. Code generated by EMF from the schema(s).  

    gen/main/java  

If one is new to EMF, one should be advised that EMF uses factories as opposed to constructors to instantiate its objects.  Other than that EMF obects can be used as if they were Java Beans. 

## Using fhir.emf as a dependency:

### Maven:  

    <dependency>
        <groupId>org.hl7.fhir</groupId>
        <artifactId>fhir.emf</artifactId>
        <version>4.0.1</version>
    </dependency>
    <dependency>
        <groupId>org.emfjson</groupId>
        <artifactId>emfjson-jackson</artifactId>
        <version>1.3.0/version>
    </dependency>

### The following are not available through Maven Central.  They must be installed into .m2 from the ecliipse distribution.
    <dependency>
        <groupId>org.eclipse.emf</groupId>
        <artifactId>org.eclipse.emf.common</artifactId>
        <version>2.20.0/version>
    </dependency>
    <dependency>
        <groupId>org.eclipse.emf</groupId>
        <artifactId>org.eclipse.emf.ecore</artifactId>
        <version>2.20.0/version>
    </dependency>
    <dependency>
        <groupId>org.eclipse.emf/groupId>
        <artifactId>org.eclipse.emf.ecore.xmi</artifactId>
        <version>2.16.0/version>
    </dependency>

### Gradle:  

    api 'org.hl7.fhir:fhir.emf:4.0.1'
    api 'org.emfjson:emfjson-jackson:1.3.0'

### The following are not available through Maven Central.  They must be installed into .m2 from the ecliipse distribution.    
    api 'org.eclipse.emf:org.eclipse.emf.common:2.20.0'
    api 'org.eclipse.emf:org.eclipse.emf.ecore:2.23.0'
    api 'org.eclipse.emf:org.eclipse.emf.ecore.xmi:2.16.0'
